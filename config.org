#+TITLE: Config
Place your private configuration here! Remember, you do not need to run `doom
sync` after modifying this file!


Reference variables which are unique to a given computer (thus the separate file)
#+INCLUDE: localLocations.org
* Overview
Here are some additional functions/macros that could help you configure Doom:
 - `load!' for loading external *.el files relative to this one
 - `use-package!' for configuring packages
 - `after!' for running code after a package has loaded
 - `add-load-path!' for adding directories to the `load-path', relative to
   this file. Emacs searches the `load-path' when you load packages with
   `require' or `use-package'.
 - `map!' for binding new keys

To get information about any of these functions/macros, move the cursor over
the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
This will open documentation for it, including demos of how they are used.

You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
they are implemented.
* fonts and theme 
Doom exposes five (optional) variables for controlling fonts in Doom. Here are
the three important ones:
  + `doom-font'
  + `doom-variable-pitch-font'
  + `doom-big-font' -- used for `doom-big-font-mode'; use this for presentations
    or streaming.


They all accept either a font-spec, font string ("Input Mono-12"), or xlfd font
string. You generally only need these two:
#+begin_src elisp :tangle yes
(setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
       doom-variable-pitch-font (font-spec :family "sans" :size 13))
#+END_SRC

There are two ways to load a theme. Both assume the theme is installed and
 available. You can either set `doom-theme' or manually load a theme with the
 `load-theme' function. This is the default:
#+begin_src elisp :tangle yes
(setq doom-theme 'doom-one)
#+END_SRC



This determines the style of line numbers in effect. If set to `nil', line
numbers are disabled. For relative line numbers, set this to `relative'.
#+begin_src elisp :tangle yes
(setq display-line-numbers-type `relative)
#+END_SRC

* TODOs
** [x] fix org-mode always having helm pop up
** [x] add julia-repl-mode hooks
** [ ] add +hook+ functional hook for +word-wrap-mode to julia-repl-mode
** [ ] expand company usability
** [ ] jupyter notebooks
** [ ] get ob-ein functional/ some way of running interesting code in org mode
** [ ] actually useful calculator
because the built-in one uses polish notation
** [ ] symon (if ever remote again)
** [ ] evil-quickscope seems to have introduced an error into f
** [ ] evil-jump-item is taking precedence over magit
this is probably not my problem tbh. just stay up to date w/doom
** [ ] spell-check personal dictionary is a bit weird
** [ ] Give conda some keybindings
e.g. conda-env-activate is good. also run-python
** Various elfeed ideas
*** [ ] sort numerically using elfeed score
**** [ ] normalize scores based on throughput rate
So that recency matters, but so there is an equal probability of getting an
article from each source.
elfeed-score assigns integers. probably best to bin at the level of day.
Each feed gets a rate, and the score is rate*(date-today)

To be concrete, lets say there's a feed w/100 entries a day, another w/1 a day, another w/10 a day, but all on the same day (long runs w/nothing)
A couple of methods:
 - +Scores constantly increase by ~10 every few days, with the 100 one+
 - In some ways we're trying to approximate sort by taking first item from source 1, first item from source 2..., second item from source 1, etc.
   + Every time we update the feed, rank each article as the (-n*10)th example from source y, and then adjust accordingly for other rules. This involves changing the score of *every* article when we update.
   + This would be much easier if this were floats instead
- Adjust the way the comparison works so when things are re-ranked, they use the date as well. Have the rate be feed dependent so that low-rate releases are less time sensitive.
=elfeed-score-sort= is apparently the relevant function
*****

*** [ ] wider feed title and tags, narrower article title
*** [ ] Sort by old and exclude high frequency
*** [ ] run update-elfeed when nothing else is happening or has happened recently
*** [ ] assign some leader key and keybindings
this is to go to specific searches using bookmarks
(defun actuator-elfeed-show-all ()
  (interactive)
  (bookmark-maybe-load-default-file)
  (bookmark-jump "elfeed-all"))
(defun actuator-elfeed-show-unread ()
  (interactive)
  (bookmark-maybe-load-default-file)
  (bookmark-jump "elfeed-unread"))

*** [ ] possibly add some entry-title colon headings
entry-title: \(emacs\|org-mode\) Tags any blog post with "emacs" or "org-mode" in the title according to it's given and inherited tags (in the example above "emacs", "mustread" and "dev").

*** [ ] things to filter out
police reports in the local news section.
;; Building subset feeds
(add-hook 'elfeed-new-entry-hook
          (elfeed-make-tagger :feed-url "example\\.com"
                              :entry-title '(not "something interesting")
                              :add 'junk
                              :remove 'unread))

**** Or put in a toxic category
Kardashian, Trump

*** [ ] default doesn't show podcasts

** Things to figure out
- git timemachine in eevil
- yasnippets
-

* Useful variables
doom folder location
#+begin_src elisp :tangle yes
(setq own-doom-home "/home/dsweber/.doom.d/")
#+end_src
* Base Settings and new functions

camelCaseIsHowIRollInCode
#+begin_src elisp :tangle yes
(add-hook 'prog-mode-hook 'subword-mode)
#+END_SRC

input via tex allows for easy unicode
#+begin_src elisp :tangle yes
(setq default-input-method "TeX")
#+END_SRC

I don't like lockfiles, as they just create clutter
#+begin_src elisp :tangle yes
(setq create-lockfiles nil)
#+END_SRC

electric pairs are better
#+begin_src elisp :tangle yes
(setq electric-pair-mode t)
#+end_src

auto-fill mode (hard wrapping is nice methinks)
#+begin_src elisp tangle:no
(setq-default auto-fill-function 'do-auto-fill)
#+end_src
** New functions
#+begin_src elisp :tangle yes
(defun add-electric-pairs (new-pairs)
  (setq-local electric-pair-pairs (append electric-pair-pairs new-pairs)))
#+END_SRC
** Mark/unmark matching (currently off)
#+begin_src elisp :tangle yes
(global-set-key (kbd "M-n") 'mc/mark-next-like-this)
(global-set-key (kbd "M-N") 'mc/unmark-next-like-this)
(global-set-key (kbd "M-p") 'mc/mark-previous-like-this)
(global-set-key (kbd "M-P") 'mc/unmark-previous-like-this)
(global-set-key (kbd "C-c n") 'mc/mark-all-like-this)
(global-set-key (kbd "C-M-]") 'mc/mark-sgml-tag-pair)
#+END_SRC

* Ace stuff
So the default switch windows binding is too deep for my taste, so I'm switching
it with the meta key of facemenu
#+begin_src elisp :tangle yes
(after! ace-window
  (global-set-key (kbd "M-o") 'ace-window)
  ;;(global-set-key (kbd "C-x o") 'facemenu-menu)
  (setq aw-dispatch-always 3)
  (setq aw-kes '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?: ?'))
  (setq aw-scome 'frame)
  (setq aw-make-frame-char ?n)
  (setq aw-dispatch-alist
        '((?x aw-delete-window "Delete Window")
          (?m aw-move-window "Swap Windows")
          (?c aw-copy-window "Move Window")
          (?b aw-switch-buffer-in-window "Select Buffer")
          (?p aw-flip-window "Flip Window")
          (?o aw-switch-buffer-other-window "Switch Buffer in another window")
          (?r aw-split-window-fair "Split fair window")
          (?z aw-split-window-vert "Split Vertical Window")
          (?v aw-split-window-horz "Split Window horizontally")
          (?? aw-show-dispatch-help)
          ))
  )
#+End_src
* Modifying doom installed packages
** company stuff:
#+begin_src elisp :tangle yes
(after! company-dict
  (setq company-dict-dir (concat user-emacs-directory "dict/"))
  (setq backends-for-everywhere '(company-bibtex company-ispell))
  (setq company-backends (append company-backends backends-for-everywhere)))
#+END_SRC
**  Auctex
#+begin_src elisp :tangle yes
(after! tex
  (setq-default TeX-master 'dwim)
  (setq TeX-save-query nil)
  (setq Tex-PDF-mode t)
  (setq reftex-default-bibliography "~/allHail/LaTeX/oneBibToRuleThemAll.bib")
)
#+END_SRC

** aspell dictionary spell whatever you want to call it:
#+begin_src elisp :tangle yes
(after! spell-fu
  (setq ispell-dictionary "en-custom")
  (setq ispell-personal-dictionary (concat own-doom-home "personal.txt"))
  )
#+end_src
* Org settings
org ref is excellent.

#+BEGIN_SRC elisp :tangle yes
(use-package! org-ref
  :config
  (setq orgRefDir "~/allHail/LaTeX/")
  (setq reftex-default-bibliography (concat orgRefDir "oneBibToRuleThemAll.bib")
        org-ref-default-bibliography (concat orgRefDir "oneBibToRuleThemAll.bib")
        org-ref-bibliography-notes (concat orgRefDir "oneBibToRuleThemAll.org")
        bibtex-completion-bibliography (concat orgRefDir "oneBibToRuleThemAll.bib")
        bibtex-completion-library-path "~/allHail/zoteroFiles"
        bibtex-completion-notes-path (concat orgRefDir "hem-bibtex-notes"))
  )
(map! :leader
      :desc "insert a helm reference"
      "i c" 'org-ref-helm-insert-cite-link)
#+END_SRC

I would like company do to things in org-mode yes please thankyou
#+begin_src elisp :tangle yes
(after! org
  :config
  (setq org-startup-with-latex-preview t)
  (setq org-startup-with-inline-images t)
  )
#+END_SRC
this allows for pairing $ in org mode files, and makes compiling to LaTeX
functional. TODO not sure why borked
#  (defvar org-pairs '((?\$ ?\$)) "Electric pairs needed in org mode not in it")

 #  (defun add-electric-pairs (new-pairs)
 #    (setq-local electric-pair-pairs (append electric-pair-pairs new-pairs)))
 #  (add-hook 'org-mode-hook '(add-electric-pairs org-pairs))
 # (setq org-latex-pdf-process (quote ( "latexmk -shell-escape -bibtex -f -pdf %f")))
 # )

whenever you're over a latex fragment, it will compile. Also, get the resolution correct
#+begin_src elisp :tangle no
(use-package! org-fragtog
  :config
  (add-hook 'org-mode-hook 'org-fragtog-mode)
  (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.5))
)
#+end_src

* Julia Settings
First, let's define the current version of Julia
#+begin_src elisp :tangle yes
(after! julia-repl 
  (setq juliaVersion "1.5.3"))
#+END_SRC


I've mostly borrowed this from https://www.gtrun.org/post/config/#julia.
Apparently non-Jedi has been making an emacs interface for the lsp [[https://github.com/non-Jedi/lsp-julia.git][here.]] Also,
this julia code doesn't actually need to be tangled, but should be run
beforehand.
#+BEGIN_SRC julia :tangle no
juliaVersion = "1.5.3"
using Pkg, PackageCompiler
Pkg.activate("~/.julia/environments/newBase")
Pkg.add("LanguageServer")
create_sysimage(:LanguageServer,
                sysimage_path = "/home/dsweber/julia-$(juliaVersion)/lib/LspSysImage.so")
#+END_SRC

and now the actual code to be tangled into ~init.el~.
#+begin_src elisp :tangle yes
(use-package! lsp-julia
  :after
  julia-repl
  :config
  (setenv "PATH"
          (concat
           "/home/dsweber/julia-" juliaVersion "/bin" ":"
           (getenv "PATH")))
  (add-hook 'julia-mode-hook 'lsp)
  (add-hook 'ess-julia-mode-hook #'lsp)
  (setq lsp-julia-default-environment "~/.julia/environments/v1.5")

  (setq lsp-julia-timeout 12000)
  ;; (add-to-list 'lsp-julia-flags (concat "-J /home/dsweber/julia-"
  ;;                                       juliaVersion "/lib/lspSysImage.so"))
  ;; (setq lsp-julia-command (concat "/home/dsweber/julia-"
  ;;                                 juliaVersion "/bin/julia "
  ;;                                 "-q -J /home/dsweber/julia-"
  ;;                                 juliaVersion "/lib/lspSysImage.so"))
  (setq lsp-enable-folding t)
  (setq julia-indent-offset 4)
  )
(setq julia-indent-offset 4)
#+END_SRC

It appears that julia-repl also has some settings to adjust
#+begin_src elisp :tangle yes
(after! julia-repl
  (setq julia-repl-executable-records
        `((default ,(concat "/home/dsweber/julia-" juliaVersion
                            "/bin/julia") :basedir
                            nil)
          )
        )
  :hook '(julia-repl-mode-hook +word-wrap-mode)
  )
#+end_src
* Evil Settings

because I have some odd preferences about how top middle bottom should work
#+begin_src elisp :tangle yes
(after! evil
  (define-key evil-normal-state-map "M" 'evil-scroll-line-to-center)
  (define-key evil-normal-state-map "L" 'evil-scroll-line-to-bottom)
  (define-key evil-normal-state-map "H" 'evil-scroll-line-to-top)
  (define-key evil-normal-state-map "zM" 'evil-window-middle)
  (define-key evil-normal-state-map "zL" 'evil-window-bottom)
  (define-key evil-normal-state-map "zH" 'evil-window-top)
  (define-key evil-normal-state-map "zl" 'evil-scroll-left)
  (define-key evil-normal-state-map "zH" 'evil-scroll-right)
  (define-key evil-normal-state-map "zH" 'evil-window-top)
  (setq evil-cross-lines t) ;; fF etc go beyond the current line
  (setq evil-want-Y-yank-to-eol 'nil)
  )
#+END_SRC

quickscope highlights what letters are unique for the purpose of jumping.
#+begin_src elisp :tangle yes
(use-package! evil-quickscope
  :config
  (global-evil-quickscope-mode 1)
  (setq evil-quickscope-cross-lines t)
  )
#+end_src

fringe marks are more legible
#+begin_src elisp :tangle yes
(use-package! evil-fringe-mark
  :config
  (global-evil-fringe-mark-mode))
#+end_src

evil numbers increments and decrements numbers. useful for adding numbers
(repeat the command e.g. 45 times)
#+begin_src elisp :tangle yes
(after! evil-numbers
  (define-key evil-normal-state-map (kbd "zq") 'evil-numbers/inc-at-pt)
  (define-key evil-normal-state-map (kbd "zq") 'evil-numbers/inc-at-pt)
  )
#+end_src
* Elfeed settings

The actual feed list and general settings are over at elfeedSources
#+begin_src elisp :tangle yes
(setq rmh-elfeed-org-files (list (concat own-doom-home "elfeedSources.org")))
#+end_src

Set default time window.
#+begin_src elisp :tangle yes
(after! elfeed
  (setq elfeed-search-filter "@2-weeks-ago +unread "))
#+end_src

update feed when idle for 5 minutes
#+begin_src elisp :tangle yes
;;(add-hook! 'elfeed-search-mode-hook 'elfeed-update)
#+end_src

The elfeed goodies collection. See customize for more values
#+begin_src elisp :tangle yes
(use-package! elfeed-goodies
  :config
  (setq elfeed-goodies/entry-pane-position :bottom)
  (elfeed-goodies/setup)
  )
#+end_src
Display the date
#+begin_src elisp :tangle yes
(after! elfeed
  (defun elfeed-search-format-date (date)
    (format-time-string "%Y-%m-%d %H:%M" (seconds-to-time date))))
#+end_src

Elscore settings
#+begin_src elisp :tangle yes
(use-package! elfeed-score
  :config
  (setq elfeed-score/score-file (concat own-doom-home "elfeed.score"))
  (define-key elfeed-search-mode-map "a" elfeed-score-map)
  )
#+end_src
